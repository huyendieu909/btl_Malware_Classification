# Malware_Classification
Classification of malware images using reduced feature subsets and multi-class support vector machines (SVM)
This work is supported by King Fahd University of Petroleum and Minerals (KFUPM) - Dhahran - Saudi Arabia. 
Joint work with Dr. Muhammad Imam - Department of Computer Engieering - KFUPM University. 

To run the code you need to install the UCSB malware image dataset available at: 

https://vision.ece.ucsb.edu/research/signal-processing-malware-analysis

Make sure to have the following folder structure to run the code properly:

Folder name: malimg_paper_dataset_imgs

Sub-folder names:

Adialer.C

Agent.FYI

Allaple.A

Allaple.L

Alueron.gen!J

Autorun.K

C2LOP.gen!g

C2LOP.P

Dialplatform.B

Dontovo.A

Fakerean

Instantaccess

Lolyda.AA1

Lolyda.AA2

Lolyda.AA3

Lolyda.AT

Malex.gen!J

Obfuscator.AD

Rbot!gen

Skintrim.N

Swizzor.gen!E

Swizzor.gen!I

VB.AT

Wintrim.BX

Yuner.A



# # python UCSB_malware_image_classification.py -nc 150 -min_im 90 -wh_c True -vis_c False
# # python UCSB_malware_image_classification.py -nc 20 -min_im 300 -wh_c 1 -vis_c 0 ---> 0.9711111111111111
# if __name__ == "__main__":
# 	argv = sys.argv[1:]
# 	parser = argparse.ArgumentParser()
# 	# nc: Number of PC Components
# 	# nc_comp defines the number of retained PC components
# 	parser.add_argument('-nc', '--n_comp', default = 100, type = int)
# 	parser.add_argument('-min_im', '--min_images', default = 50, type = int)
# 	parser.add_argument('-wh_c', '--whiten_check', default = 1, type = int)
# 	parser.add_argument('-vis_c', '--visualize_check', default = 0, type = int)

# 	args = parser.parse_args()      
# 	n_comp = args.n_comp
# 	min_imgs = args.min_images
# 	whiten_int = args.whiten_check
# 	visualize_int = args.visualize_check

# 	if whiten_int == 1:
# 		whiten = True
# 	else:
# 		whiten = False

# 	if visualize_int == 1:
# 		visualize = True
# 	else:
# 		visualize = False

# 	print('No of PCs')
# 	print(n_comp)
# 	print('No of min_images')
# 	print(min_imgs)

# 	# Load the UCSB malware image dataset
# 	print("[INFO] loading UCSB malware image dataset...")
# 	training, testing, labels = load_ucsb_malware_images('malimg_paper_dataset_imgs', min_images = min_imgs, flatten = True, test_size = 0.25)

# 	# Handle if sklearn is < 0.18 where we use RandomizedPCA
# 	if is_sklearn_less_than_0_18():
# 		print("[INFO] sklearn == {}, so using RandomizedPCA".format(sklearn.__version__))
# 		from sklearn.decomposition import PCA as RandomizedPCA
# 	# otherwise sklearn's RandomizedPCA is deprecated and we need to use PCA
# 	else:
# 		print("[INFO] sklearn=={}, so using PCA".format(sklearn.__version__))
# 		from sklearn.decomposition import PCA


# 	# compute the PCA (eigenvectors) representation of the data, then project the training data
# 	# onto the eigenvectors subspace
# 	print("[INFO] creating eigenvectors for the malware images...")

# 	# handle if sklearn is < 0.18
# 	if is_sklearn_less_than_0_18():
# 		pca = RandomizedPCA(n_components = n_comp, whiten = whiten)
# 	# otherwise sklearn is >= 0.18
# 	else:
# 		pca = PCA(svd_solver="randomized", n_components = n_comp, whiten = whiten)


# 	trainData = pca.fit_transform(training.data)

# #	check to see if the PCA components should be visualized
# 	if visualize == True:
# 		# initialize the montage for the components
# 		montage = ResultsMontage((100, 128), 4, 16) 

# 		# loop over the first 16 individual components
# 		for (i, component) in enumerate(pca.components_[:16]):
# 			# reshape the component to a 2D matrix, then convert the data type to an unsigned
# 			# 8-bit integer so it can be displayed with OpenCV
# 			component = component.reshape((100, 128))
# 			component = exposure.rescale_intensity(component, out_range=(0, 255)).astype("uint8")
# 			component = np.dstack([component] * 3)
# 			montage.addResult(component)

# 		# show the mean and principal component visualizations
# 		# show the mean image
# 		mean = pca.mean_.reshape((100, 128))
# 		mean = exposure.rescale_intensity(mean, out_range=(0, 255)).astype("uint8")
# 		cv2.imshow("Mean Malware Image", mean)
# 		cv2.imshow("Eigen Malware", montage.montage)
# 		cv2.waitKey(0)


# 	# train a classifier on the eigenfaces representation
# 	print("[INFO] training classifier...")
# 	model = SVC(kernel = "rbf", C = 10.0, gamma = 0.001, random_state = 84)
# 	model.fit(trainData, training.target)

# 	# evaluate the model
# 	print("[INFO] evaluating model...")
# 	predictions = model.predict(pca.transform(testing.data))
# 	print(classification_report(testing.target, predictions))

# 	# Convert the malware names to class labels
# 	le = preprocessing.LabelEncoder()
# 	le.fit(labels)
# #	print(le.classes_)
# 	#num_labels = le.transform(le.classes_)
# 	# print(num_labels)
# #	print(confusion_matrix(testing.target, predictions, labels=le.classes_)) #range(np.max(num_labels))
# 	print(accuracy_score(testing.target, predictions))


	# loop over the the desired number of samples
	# for i in np.random.randint(0, high=len(testing.data), size=(10, )):
	# 	# grab the malware image and classify it
	# 	malware_image = testing.data[i].reshape((100, 128)).astype("uint8")
	# 	prediction = model.predict(pca.transform(testing.data[i].reshape(1, -1)))

	# 	# resize the face to make it more visable, then display the face and the prediction
	# 	print("[INFO] Prediction: {}, Actual: {}".format(prediction[0], testing.target[i]))
	# 	malware_image = imutils.resize(malware_image, width=malware_image.shape[1] * 2, inter=cv2.INTER_CUBIC)
	# 	cv2.imshow("Malware", malware_image)
	# 	cv2.waitKey(0)